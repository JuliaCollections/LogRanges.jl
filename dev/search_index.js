var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = LogRanges","category":"page"},{"location":"#LogRanges","page":"Home","title":"LogRanges","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for LogRanges.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [LogRanges]","category":"page"},{"location":"#LogRanges.LogRange","page":"Home","title":"LogRanges.LogRange","text":"LogRange{T}(start, stop, len) <: AbstractVector{T}\n\nA range whose elements are spaced logarithmically between start and stop, with spacing controlled by len. Returned by logrange.\n\nLike Base.LinRange, the first and last elements will be exactly those provided, but intermediate values may have small floating-point errors. These are calculated using the logs of the endpoints, which are stored on construction, often in higher precision than T.\n\nNegative values of start and stop are allowed, but both must have the same sign. For complex T, all points lie on the same branch of log as used by log(start) and log(stop).\n\nExamples\n\njulia> LogRange(1, 4, 5)\n5-element LogRange{Float64, Base.TwicePrecision{Float64}}:\n 1.0, 1.41421, 2.0, 2.82843, 4.0\n\njulia> LogRange{Float16}(-1, -4, 5)\n5-element LogRange{Float16, Float64}:\n -1.0, -1.414, -2.0, -2.828, -4.0\n\njulia> LogRange(1e-310, 1e-300, 11)[1:2:end]\n6-element Vector{Float64}:\n 1.0e-310\n 9.999999999999974e-309\n 9.999999999999981e-307\n 9.999999999999988e-305\n 9.999999999999994e-303\n 1.0e-300\n\njulia> prevfloat(1e-308, 5) == ans[2]\ntrue\n\njulia> LogRange{ComplexF32}(1, -1 +0.0im, 5) |> collect\n5-element Vector{ComplexF32}:\n         1.0f0 + 0.0f0im\n  0.70710677f0 + 0.70710677f0im\n  6.123234f-17 + 1.0f0im\n -0.70710677f0 + 0.70710677f0im\n        -1.0f0 + 0.0f0im\n\njulia> ans ≈ cis.(LinRange{Float32}(0, pi, 5))\ntrue\n\njulia> LogRange(2, Inf, 5)\n5-element LogRange{Float64, Base.TwicePrecision{Float64}}:\n 2.0, Inf, Inf, Inf, Inf\n\njulia> LogRange(0, 4, 5)\n5-element LogRange{Float64, Base.TwicePrecision{Float64}}:\n NaN, NaN, NaN, NaN, 4.0\n\n\n\n\n\n","category":"type"},{"location":"#LogRanges.logrange-Tuple{Number, Number, Integer}","page":"Home","title":"LogRanges.logrange","text":"logrange(start, stop, length)\nlogrange(start, stop; length)\n\nConstruct a specialized array whose elements are spaced logarithmically between the given endpoints. That is, the ratio of successive elements is a constant, calculated from the length.\n\nSee also Base.range for linearly spaced points.\n\nExamples\n\njulia> logrange(10, 4000, length=3)\n3-element LogRange{Float64, Base.TwicePrecision{Float64}}:\n 10.0, 200.0, 4000.0\n\njulia> ans[2] ≈ sqrt(10 * 4000)  # middle element is the geometric mean\ntrue\n\njulia> range(10, 40, length=3)[2] ≈ (10 + 40)/2  # arithmetic mean\ntrue\n\njulia> logrange(1f0, 32f0, 11)\n11-element LogRange{Float32, Float64}:\n 1.0, 1.41421, 2.0, 2.82843, 4.0, 5.65685, 8.0, 11.3137, 16.0, 22.6274, 32.0\n\njulia> logrange(1, 1000, length=4) ≈ 10 .^ (0:3)\ntrue\n\njulia> logrange(-27, -3, length=7)  # allows negative numbers\n7-element LogRange{Float64, Base.TwicePrecision{Float64}}:\n -27.0, -18.7208, -12.9802, -9.0, -6.24025, -4.32675, -3.0\n\n\n\n\n\n","category":"method"},{"location":"#LogRanges.splitbits-Tuple{Float64}","page":"Home","title":"LogRanges.splitbits","text":"Splits a Float64 into a hi bit and a low bit where the high bit has 27 trailing 0s and the low bit has 26 trailing 0s\n\n\n\n\n\n","category":"method"}]
}
